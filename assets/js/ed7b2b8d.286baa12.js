"use strict";(self.webpackChunktu_cis_4398_docs_template=self.webpackChunktu_cis_4398_docs_template||[]).push([[3961],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(t),g=i,m=p["".concat(l,".").concat(g)]||p[g]||c[g]||r;return t?a.createElement(m,o(o({ref:n},u),{},{components:t})):a.createElement(m,o({ref:n},u))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},5531:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=t(7462),i=(t(7294),t(3905));const r={sidebar_position:1},o="Design",s={unversionedId:"system-architecture/design",id:"system-architecture/design",title:"Design",description:"Components",source:"@site/docs/system-architecture/design.md",sourceDirName:"system-architecture",slug:"/system-architecture/design",permalink:"/project-groupmeet/docs/system-architecture/design",draft:!1,editUrl:"https://github.com/Capstone-Projects-2023-Spring/project-groupmeet/edit/main/documentation/docs/system-architecture/design.md",tags:[],version:"current",lastUpdatedBy:"tweiss9",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"System Architecture",permalink:"/project-groupmeet/docs/category/system-architecture"},next:{title:"API Specification",permalink:"/project-groupmeet/docs/category/api-specification"}},l={},d=[],u={toc:d};function p(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"design"},"Design"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Components")),(0,i.kt)("p",null,"Round is an iOS/Android application that utilizes Google Firebase for the backend, and Flutter for the frontend."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Algorithms")),(0,i.kt)("p",null,"Round implements a sorting algorithm to display a non-invasive view of all times a group's members are busy. This will allow them to have a visual representation of general available days/times, without any extra details such as what the event times actually contain (Round only stores the start and end times of each event). Additionally, Round has the capacity to determine the next available time for a potential meeting by using these stored event times as references."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Class Diagrams"),"\n",(0,i.kt)("strong",{parentName:"p"},"Diagram 1 - Classes Related to Calendar Creation, Display, and Integration")),(0,i.kt)("mermaid",{value:"classDiagram    \n    class CalendarPage {\n        <<StatefulWidget>>\n        +group: Map<dynamic, dynamic>?\n        +title: String\n    }\n    _CalendarPageState--|>CalendarPage\n    class _CalendarPageState{\n        -allEvents: List<Appointment>\n        -getData(): Future<List<Appointment>>\n        -chosenDateAddedToCalendar(begTime: DateTime, finTime: DateTime, meetingName: String)\n        -_googleSignIn: GoogleSignIn\n        -_currentUser: GoogleSignInAccount?\n        -_handleSignIn()\n        -getPrimaryCalendar()\n    }\n    class Appointment {\n        -startTime: DateTime\n        -endTime: DateTime\n    }\n    _CalendarPageState --|> Appointment\n\n    class CalendarSelection {\n        - bool fromSettings\n        - DatabaseReference ref\n        - GoogleSignInAccount? _currentUser\n        - GoogleSignIn _googleSignIn\n        + CalendarSelection(super.key, required this.fromSettings)\n        + buttonPress(BuildContext context)\n        + pressedGoogle(BuildContext context): Future<void>\n        + pressedApple(BuildContext context)\n        + build(BuildContext context): Widget\n    }\n\n    class Calendar {\n        - GoogleSignInAccount _currentUser\n        - DatabaseReference ref\n        - GoogleSignIn _googleSignIn\n        + Calendar(Key? key)\n        + getGoogleCalendar() : Future<void>\n        + _handleSignIn() : Future<void>\n        + initState() : void\n        + build(BuildContext) : Widget\n    }\n    class _CalendarState {\n        + initState() : void\n        - final GoogleSignIn _googleSignIn\n        - Future<void> _handleSignIn() : Future<void>\n        + getGoogleCalendar() : Future<void>\n        - late DatabaseReference ref\n        - GoogleSignInAccount? _currentUser\n    }\n    _CalendarState--|>Calendar"}),(0,i.kt)("p",null,"Diagram 1 shows all the UML for the classes related to creation, maintenance, and display of the calendars within Round. As can be seen, there are not many external dependencies save from a utility class called Appointments that is seen throughout, and library imports which are not included for cleanliness, but can be seen in diagram 7. Also note there are constant relationships between classes that look somewhat like the following: ClassState inherits from Class. This relationship is further described for the stateful widgets in diagram 8. CalendarSelection is a Stateless Widget, and as a result does not have that relationship.\n",(0,i.kt)("strong",{parentName:"p"},"Diagram 2 - Classes Related to Code Generation, Usage, and Display (both QR and String)")),(0,i.kt)("mermaid",{value:"classDiagram\n    class CodeReception {\n        - TextEditingController groupId\n        - int one\n        + openDialog()\n        + updateDatabase()\n        + camScanner()\n        + build()\n    }\n    class _CodeReceptionState{\n        +title\n    }\n    CodeReception --\x3e _CodeReceptionState\n\n    class CodeSharing {\n        - String title\n        - Future<DataSnapshot> _grabGroupId()\n        + void getCode()\n        + Widget build(BuildContext context)\n        }\n    class _CodeSharingState{\n        + void getCode()\n        + Widget build(BuildContext context)\n    }\n    CodeSharing --\x3e _CodeSharingState\n\n    class DisplayCode {\n        -List<dynamic> groupName\n        -List<dynamic> nameId\n        +DisplayCode(groupName, nameId, key)\n        +buildList(groupName, nameId)\n        +build(BuildContext): Widget\n    }\n\n    class NewQR {\n        - scanning: bool\n        + scanQR(context: BuildContext): void\n        + build(context: BuildContext): Widget\n        - updateDatabase(groupID): void\n    }\n\n    class Display{\n        -final groupName: String\n        -final nameId: String\n        +Display(groupName: String, nameId: String)\n        +build(context: BuildContext): Widget\n    }"}),(0,i.kt)("p",null,"Diagram 2 shows all the UML for the classes related to creation, maintenance, and display of both String and QR codes within Round. Library imports which are not included for cleanliness, but can be seen in diagram 7. Also note there are constant relationships between classes that look somewhat like the following: ClassState inherits from Class. This relationship is further described for the stateful widgets in diagram 8. DisplayCode, NewQR, and Display are Stateless Widgets, and as a result does not have that relationship."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Diagram 3 - Classes Related to Group Creation, Display, and Usage")),(0,i.kt)("mermaid",{value:"classDiagram\n    class AllGroups {\n        - final String title\n        - final DatabaseReference ref\n        - late DatabaseReference ref\n        - final String? uid\n        + grabGroups() : Future<List<Map>>\n        - firebaseDatabase : FirebaseDatabase\n        + build(context: BuildContext) : Widget\n    }\n    class _AllGroupsState {\n        - late DatabaseReference ref = widget.ref\n        + grabGroups() : Future<List<Map>>\n        - firebaseDatabase : FirebaseDatabase\n        + build(context: BuildContext) : Widget\n    }\n    AllGroups --\x3e _AllGroupsState\n\n    class GroupCreation {\n        - final String? userID\n        - final FirebaseDatabase firebaseDatabase\n        - MaterialColor? selectedColor\n        - MaterialColor? tempColor\n        - String name\n        - String emoji\n        - DatabaseReference ref\n        - String? uid\n        + GroupCreation(super.key, required this.userID, required this.firebaseDatabase)\n        + changedName(string: String): void\n        + changedEmoji(string: String): void\n        + buttonPress(context: BuildContext): Future<void>\n        + _openDialog(title: String, content: Widget): void\n        + colorTapped(): void\n        - createMaterialColor(color: Color): MaterialColor\n        - _GroupCreationState()\n        + createState(): _GroupCreationState\n    }\n\n    class _GroupCreationState {\n        + _GroupCreationState()\n        + createMaterialColor(color: Color): MaterialColor\n    }    \n    GroupCreation --\x3e _GroupCreationState\n\n\n    class NewGroupView {\n        -RoundGroup group\n    }\n    class _NewGroupView {\n        -List<GroupMember> parsedMembers\n        -List<GroupMember> rsvped\n        -int smsCount\n        -int snapCount\n        -int discordCount\n        -int instaCount\n        -int fbCount\n        -int calCount\n        -bool isObserving\n        -bool isAdmin\n        -DateTime? appointment\n        - int appointmentIndex = 0\n        + handleCalendarRequest() : void\n        + removeCurrentDate() : Future<int>\n        + getEventList() : Future<List<Appointment>>\n        + findNextBestDate() : Future<List<DateTime>>\n        + calendar() : void\n        +NewGroupView(group, super.key)\n        +_NewGroupView(group)\n        +Future<void> observeGroup()\n        +Future<DateTime?> getFirstDate()\n        +void triggerDelete()\n        +State<NewGroupView> createState()\n    }\n    class GroupMember {\n        -String uid\n        -String name\n        -String email\n        -String? snapchat\n        -String? sms\n        -String? discord\n        -String? instagram\n        -String? facebook\n        -bool? hasCalendar\n        +GroupMember(uid, name, email, snapchat, sms, discord, instagram, facebook, hasCalendar)\n    }\n\n    class Appointment {\n        - DateTime startTime\n        - DateTime endTime\n    }\n\n    NewGroupView --\x3e _NewGroupView\n    _NewGroupView --\x3e GroupMember\n    _NewGroupView --\x3e Appointment"}),(0,i.kt)("p",null,"Diagram 3 shows all the UML for the classes related to creation, maintenance, and display of the groups within Round. As can be seen, there are not many external dependencies shown within the diagram except a utility class called Appointments that is also seen in Diagram 1. Library imports, which are not included for cleanliness, can be seen in diagram 7. Also note there are constant relationships between classes that look somewhat like the following: ClassState inherits from Class. This is further explained in Diagram 8."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Diagram 4 - Classes Related to the Onboarding Process")),(0,i.kt)("mermaid",{value:'classDiagram\n    class Explainer{\n        -pageNo: int\n        -headers: String[]\n        -texts: String[]\n        -images: String[]\n        +buttonPress(context: BuildContext): void\n        +build(context: BuildContext): Widget\n    }\n    class SignIn {\n        + SignIn(super.key, required this.firebaseDatabase, required this.firebaseAuth)\n        - final FirebaseDatabase firebaseDatabase\n        - final FirebaseAuth firebaseAuth\n        - String email\n        - String password\n        + Future<void> buttonPress(BuildContext context)\n        - void signIn(BuildContext context)\n        - void changedEmail(String string)\n        - void changedPassword(String string)\n        + Widget build(BuildContext context)\n    }\n    class SignUp {\n        -FirebaseDatabase firebaseDatabase\n        -FirebaseAuth firebaseAuth\n        #String name\n        #String email\n        #String password\n        #DatabaseReference ref\n        #String? uid\n        +void changedName(String string)\n        +void changedEmail(String string)\n        +void changedPassword(String string)\n        +Future<void> buttonPress(BuildContext context)\n        +void signIn(BuildContext context)\n        +Widget build(BuildContext context)\n    }\n    class SocialOnboarding {\n        -FirebaseDatabase firebaseDatabase\n        -FirebaseAuth firebaseAuth\n        -String insta = ""\n        -String fb = ""\n        -String discord = ""\n        -String snap = ""\n        -String sms = ""\n        +void facebookChanged(String string)\n        +void instagramChanged(String string)\n        +void discordChanged(String string)\n        +void snapChanged(String string)\n        +void smsChanged(String string)\n        +void buttonPress(BuildContext context)\n        -DatabaseReference databaseReference\n        +Widget build(BuildContext context)\n    }'}),(0,i.kt)("p",null,"Diagram 4 shows all the UML for the classes related to creation, maintenance, and display of the onboarding process within Round. Library imports, which are not included for cleanliness, can be seen in diagram 7. Also note the typical ClassState inherits from Class relationship is not here, and instead these classes comprise entirely of Stateless Widgets."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Diagram 5 - Classes Related to User Settings")),(0,i.kt)("mermaid",{value:'classDiagram\n    class About {\n    - Key? key\n    - final String title\n    + State<About> createState()\n    }\n\n    class AboutState {\n    - DatabaseReference ref\n    - final GoogleSignIn _googleSignIn\n    - GoogleSignInAccount? _currentUser\n    + void initState()\n    + Future<void> getPrimaryCalendar()\n    + Widget build(BuildContext context)\n    }\n\n    About --\x3e AboutState\n\n    class AddEvent {\n    - late DateTime start\n    - late DateTime end\n    - late DatabaseReference ref\n    + AddEvent(Key? key, required this.title, required this.ref)\n    + final String title\n    + @override State<AddEvent> createState()\n    }\n\n    class _AddEventState {\n    - late DateTime start\n    - late DateTime end\n    - late DatabaseReference ref\n    + @override void initState()\n    + @override Widget build(BuildContext context)\n    }\n\n    AddEvent --\x3e _AddEventState\n\n    class EditAccountInfo{\n        +String title  \n        +DatabaseReference ref\n    }\n    class _EditAccountInfoState{\n        -String fName\n        -String lName\n        -String email\n        -DatabaseReference ref\n        -TextEditingController _firstNameController\n        -TextEditingController _lastNameController\n        -TextEditingController _emailController\n        +void initState()\n        +void getData()\n        +void saveChanges()\n        +Widget build(BuildContext context)\n    }\n    EditAccountInfo --\x3e _EditAccountInfoState\n\n    class _Settings {\n        - String name = ""\n        - String email = ""\n        - String? snap\n        - String? messages\n        - String? discord\n        - String? insta\n        - String? fb\n        - bool? cal\n        - String newName = ""\n        - String newEmail = ""\n        - bool observing = false\n        + void changedName(newName:String)\n        + void changedEmail(newEmail:String)\n        + void legacySettings()\n        + void saveInfo()\n        + void observeData()\n        + void socialChanged(text:String)\n        + Future<void> getPrimaryCalendar()\n    }\n    class Settings {\n        -FirebaseDatabase firebaseDatabase\n        -FirebaseAuth firebaseAuth\n        +Settings(super.key, firebaseDatabase:FirebaseDatabase, firebaseAuth:FirebaseAuth)\n        +State<StatefulWidget> createState()\n    }\n\n    Settings --\x3e _Settings'}),(0,i.kt)("p",null,"Diagram 5 shows all the UML for the classes related to creation, maintenance, and display of the user settings within Round, as well as the generation of custom events not associated with any calendar. As can be seen, there are not many external dependencies, and library imports which are not included for cleanliness, but can be seen in diagram 7. Also note there are constant relationships between classes that look somewhat like the following: ClassState inherits from Class. This relationship is further described for the stateful widgets in diagram 8."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Diagram 6 - Classes Related to the User's Individual Homepage and Usage")),(0,i.kt)("mermaid",{value:"classDiagram\nclass RoundGroup {\n            -String id\n            -Color color\n            -String emoji\n            -String name\n            -String admin\n            -List<String> memberIDs\n            +RoundGroup(id:String, color:Color, emoji:String, name:String, admin:String, memberIDs:List<String>)\n        }\n        class HomeScreen {\n            -FirebaseDatabase firebaseDatabase\n            -FirebaseAuth firebaseAuth\n            +HomeScreen(key:super.key, firebaseDatabase:FirebaseDatabase, firebaseAuth:FirebaseAuth)\n            +State<HomeScreen> createState()\n        }\n        class _HomeScreen {\n            -List<RoundGroup> displayedGroups\n            -bool observing\n            -String code\n            +updateDatabase(groupID:String)\n            +showQR(context:context)\n            +showAdd(context:context)\n        }\n        RoundGroup *-- _HomeScreen\n        HomeScreen --\x3e _HomeScreen\n\n    class RoundApp {\n        - Key? key\n        + RoundApp()\n        + build(BuildContext context): Widget\n    }"}),(0,i.kt)("p",null,"Diagram 6 shows all the UML for the classes related to creation, maintenance, and display of Round itself, and the user's individual home page. As can be seen, there are not many external dependencies, and library imports are not included for cleanliness. These can be seen in diagram 7. Also note there are constant relationships between classes that look somewhat like the following: ClassState inherits from Class. This relationship is further described for the stateful widgets in diagram 8. RoundApp is a Stateless Widget, and as a result does not have that relationship."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Diagram 7 - Dependencies Between all Classes seen in Diagrams 1-6")),(0,i.kt)("mermaid",{value:'classDiagram\nnote for FirebaseDatabase "External Library"\nnote for FirebaseAuthentication "External Library"\nnote for Cupertino "External Library"\nnote for Material "External Library"\nnote for PlatformWidget "External Library"\nnote for Theme "Design Used Throughout"\nRoundApp --\x3e FirebaseAuthentication\nRoundApp --\x3e FirebaseDatabase\nRoundApp --\x3e Cupertino\nRoundApp --\x3e Material\nRoundApp --\x3e PlatformWidget\nRoundApp --\x3e Explainer\nRoundApp --\x3e Theme\nRoundApp --\x3e HomeScreen\n\nHomeScreen --\x3e GroupCreation\nHomeScreen --\x3e NewGroupView\nHomeScreen --\x3e NewQR\nHomeScreen --\x3e Settings\n\nNewGroupView --\x3e HomeScreen\nNewGroupView --\x3e intl\nNewGroupView --\x3e QrFlutter\nNewGroupView --\x3e SyncFusionFlutterCalendar\nNewGroupView --\x3e CalendarPage\n\nCalendarPage --\x3e GoogleAPI\nCalendarPage --\x3e SyncFusionFlutterCalendar\nCalendarPage --\x3e AddEvent\n\nCalendarSelection --\x3e SocialOnboarding\n\nCalendar --\x3e SocialOnboarding\n\nCodeReception --\x3e BarcodeScanner\n\nCodeSharing --\x3e FlutterToast\nCodeSharing --\x3e DisplayCode\n\nNewQR --\x3e Services\nNewQR --\x3e BarcodeScanner\n\nAllGroups --\x3e GroupHomePage\nAllGroups --\x3e GroupCreation\n\nGroupHomePage --\x3e CalendarPage\nGroupHomePage --\x3e Display\nGroupHomePage --\x3e SyncFusionFlutterCalendar\n\nExplainer --\x3e Signup\n\nSignin --\x3e HomeScreen\n\nSignup --\x3e CalendarSelection\nSignup --\x3e Signin\n\nSocialOnboarding --\x3e HomeScreen\n\nAbout --\x3e AllGroups\nAbout --\x3e AddEvent\n\nSettings --\x3e CalendarSelection\nSettings --\x3e Signup'}),(0,i.kt)("p",null,'Diagram 7 shows the dependendencies of all classes seen in Diagrams 1-6, and how they are all connected within each other, and the libraries used. As can be seen in the diagram, there are many libraries that are consistently used, and these are due to them being core components throughout the application. Other dependencies, while not seemingly as critical, are still very important due to having unique but critical functionality within Round. Note that all libraries labelled "External Library" are used persistently throughout the entire application. Other external libraries, such as BarcodeScanner, are not labeled as such, but are included in every instance of their usage. This was done to clean up the diagram and make it easier to read.'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Diagram 8 - General Relationship Between State, StatefulWidget, and the way classes utilize them.")),(0,i.kt)("mermaid",{value:'classDiagram\n    class State\n    class StatefulWidget\n    \n    class GenericPage\n    class _GenericPageState\n    \n    GenericPage --|> StatefulWidget\n    note for State "Library in Flutter"\n    note for StatefulWidget "Library in Flutter"\n    _GenericPageState --|> State\n    GenericPage --\x3e _GenericPageState'}),(0,i.kt)("p",null,"Diagram 8 shows the relationship between ClassState and Class that has been mentioned in Diagrams 1-6. Both of these rely on libraries within the Flutter framework to work, however the relationship is consistently the same for all Stateful Widgets, which is why it was deemed better to save this relationship for it's own diagram rather than overcomplicate the previous diagrams."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Sequence Diagrams"),"\n",(0,i.kt)("strong",{parentName:"p"},"Use Case 1: Registration")),(0,i.kt)("mermaid",{value:"sequenceDiagram\n    actor User\n    User->>Round: Open application\n    User->>+Round: Registers using form field\n    Round->>+FirebaseAuthentication: createUserWithEmailAndPassword()\n    FirebaseAuthentication->>+RealtimeDatabase: Creates a new entry\n    RealtimeDatabase--\x3e>-FirebaseAuthentication: Creation Successful\n    FirebaseAuthentication--\x3e>-Round: Account Created\n    Round--\x3e>-User: Account Created"}),(0,i.kt)("p",null,"Use case 1 shows the registration process. This process allows the user to create an account with Round, which is then used throughout the rest of the application. The process will be user friendly, and accessible throughout onboarding."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use Case 2: First-Time Login")),(0,i.kt)("mermaid",{value:"sequenceDiagram\n    actor User\n    User->>Round: Open application\n    User->>+Round: Login\n    Round->>+FirebaseAuthentication: signInWithEmailAndPassword()\n    FirebaseAuthentication->>+RealtimeDatabase: Queries Database\n    RealtimeDatabase--\x3e>-FirebaseAuthentication: Query Successful\n    FirebaseAuthentication--\x3e>-Round: Account found\n    Round->>+RealtimeDatabase: Queries for any linked social media\n    RealtimeDatabase--\x3e>-Round: No results found\n    Round--\x3e>-User: Prompts user to link social media\n    User->>+Round: Validates social media accounts\n    Round->>+RealtimeDatabase: adds accounts to entry\n    RealtimeDatabase--\x3e>-Round: entry updated\n    Round--\x3e>-User: Thanks user for information"}),(0,i.kt)("p",null,"Use case 2 shows the login process for when a user is already registered. If they are logging in for the first time, they will have to enter their email and password. However, if they are logging in after having previously done so, their state is saved so they do not have to consistently log in every time the application was opened. This decision was made due to the overall goal of Round to make group planning and creation as streamlined as possible, with the hopes of allowing all the maintenance of groups to be done within a minute of intiation."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use Case 3: Group Creation")),(0,i.kt)("mermaid",{value:"sequenceDiagram\n    actor User\n    participant Round App\n    participant Firebase Authentication\n    participant Realtime Database\n\n    User->>+ Round App: login()\n    Round App->>+Firebase Authentication: signInWithEmailAndPassword()\n    User->>+Round App: Presses button to create a new group\n    Round App --\x3e> User: Prompts user for group information\n    User->>+Round App: Enters group information\n    Round App->>+Realtime Database : Update information to group settings"}),(0,i.kt)("p",null,"Use case 3 shows the sequence of events needed to create a group. Once the user is logged in, all they need to do is press the create group button, follow the prompts for information, and then the group is created. This group can then be sent to other members to allow them to also join the group, which is highlighted further in Use case 4."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use Case 4: Invite Other Users")),(0,i.kt)("mermaid",{value:"sequenceDiagram\n    actor User1\n    actor User2\n    participant Round App\n    participant Realtime Database\n    \n    User1->>+Round App: Presses button to create a new group\n    Round App --\x3e> User1: Prompts user for group information\n    User1->>+Round App: Enters group information\n    Round App->>+Realtime Database : Update information to group settings\n    Round App ->>+ Round App: QR code and generated code are created\n    User2->>+ User2: Scan the QR code or enter the generated code\n    User2->>+ Round App: Join scheduling group"}),(0,i.kt)("p",null,"Use case 4, as briefly mentioned above, shows how other users can join a previously created group. Once said group is initialized, the original user has to present the QR code or generated code to any other users they want to join the group. Once these codes are input by the other users, they have joined the group, and Round is able to account for their information."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use Case 5: Time Block Selection")),(0,i.kt)("mermaid",{value:"sequenceDiagram\n    actor user\n    actor groupchat\n    actor user3\n    user--\x3e>+groupchat: Sends link for installation\n    groupchat--\x3e>+App/Play Store: brings to dowload\n    App/Play Store--\x3e>+Round App: Brings to Round App\n    Round App->>-groupchat: Prompts Users to Sign Up\n    groupchat->>+Round App: Signs up\n    Round App--\x3e>+Database: Updates Database Info\n    Round App->>+groupchat: Prompts User to Sync Google Calendar\n    groupchat->>+Round App: Confirm Syncing of Calendar\n    Round App->>+Google Calendar: Request Calendar Info\n    Google Calendar->>-Round App: Send's Calendar Info\n    Round App->>+user3: Request to Sync Calendar\n    user3->>+Round App: Denies Requests\n    Round App->>+Round App: Syncs Calendar Info\n    Round App->>+Round App: Places Participants in Group\n    Round App->>+user3: Prompts User to Selected From Static Calendar\n    user3->>+Round App: User Completes Calendar Filling Request\n    Round App->>+Round App: Finalizes Calendar\n    Round App->>+Round App: Publishes Times of Best Fitted Availability in Internalize Group"}),(0,i.kt)("p",null,"Use case 5 is a relatively complicated scenario, but explains how time blocks are created. In summary, the founding user creates the group and invites all other users to the group. Once that is done, the users can choose to integrate their Google calendar so the event start and end times are saved for future reference (no other personal data is ever stored in regards to event information, solely the start and end times). Afterwards, any user may choose to ask for a meeting time to be generated, in which Round will then use all stored events to find the next best time for a meeting between all users."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use Case 6: Last Second Changes")),(0,i.kt)("mermaid",{value:"sequenceDiagram\n    actor Group\n    actor UserX\n    actor UserY\n    participant Round App\n\n    Group->>Round App: All users join the group\n    Round App->>+ Round App: Static Calendar is generated with everyone's schedules\n    UserX->>Round App: User requests a new meeting time.\n    Round App->>Group: First available time is displayed to all members.\n    UserY->>Round App: User later realizes that they actually cannot make that time, and requests a new time.\n    UserY->>Round App: Cancels the current meeting time\n    Round App->>Group: Selects and displays the next best time on a different day.\n"}),(0,i.kt)("p",null,"Use case 6 shows what would happen if a time was chosen, and then another user realizes they cannot attend that meeting. Upon realization, the user just needs to notify Round through a button press. Round will then pick the next best day to have a meeting. Round will always pick another day entirely, under the assumption that if someone is unable to make a meeting time due to a last minute change, then the change likely has an unknown end time on that day, so a new day altogether is the best chance for a successful meeting."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use Case 7: Push Notifications and Reminders")),(0,i.kt)("mermaid",{value:'sequenceDiagram\n    actor User\n    participant Round App\n    participant Message Server\n\n    Round App->>User: Receives a meeting reminder message\n    User->>Round App: Taps on the message\n    Round App->>Message Server: Fetches details about the meeting\n    Message Server->>Round App: Return details about the meeting\n    Round App->>User: Shows a pop-up message with meeting details\n    User->>Round App: Taps on the active status\n    Round App->>User: Shows a description of the status\n    User->>Round App: Clicks on the "X" button\n    Round App->>User: Closes the pop-up menu\n    User->>Round App: Returns to the app\'s home page\n    Round App->>User: Brings user back to homepage'}),(0,i.kt)("p",null,"Use case 7 shows how push notification would affect users in Round. Due to the unexpected complexity of push notifications, this was not included in the current version of Round, but it is a very possible feature to be implemented in the future. What would happen is Round would load the upcoming meeting time, and send notifications to the users in a timely manner to allow them to know the state of the meeting, such as if it was cancelled or delayed. Additionally, there would be reminders sent out to the users to assist them with managing their schedule for all groups associated with Round."),(0,i.kt)("p",null,"**Entity-relation diagram"),(0,i.kt)("mermaid",{value:"erDiagram\n    Users{\n        string uid \n        string name\n        string email    \n        Object socialMedia[]\n        string teamIds[]\n    }\n    Teams{\n        string teamId \n        string teamName\n        string teamAdmin\n        string uids[]\n    }\n    Users }|..|{ Teams: have"}),(0,i.kt)("p",null,"Table design."),(0,i.kt)("p",null,"A check list for architecture design is attached here ",(0,i.kt)("a",{parentName:"p",href:"https://templeu.instructure.com/courses/106563/files/16928870/download?wrap=1",title:"architecture_design_checklist.pdf"},"architecture","_","design","_","checklist.pdf"),"\xa0 and should be used as a guidance."))}p.isMDXComponent=!0}}]);